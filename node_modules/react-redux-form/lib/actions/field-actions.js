'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _get2 = require('../utils/get');

var _get3 = _interopRequireDefault(_get2);

var _mapValues = require('../utils/map-values');

var _mapValues2 = _interopRequireDefault(_mapValues);

var _actionTypes = require('../action-types');

var _actionTypes2 = _interopRequireDefault(_actionTypes);

var _batchActions = require('./batch-actions');

var _batchActions2 = _interopRequireDefault(_batchActions);

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var focus = function focus(model) {
  return {
    type: _actionTypes2.default.FOCUS,
    model: model
  };
};

var blur = function blur(model) {
  return {
    type: _actionTypes2.default.BLUR,
    model: model
  };
};

var setPristine = function setPristine(model) {
  return {
    type: _actionTypes2.default.SET_PRISTINE,
    model: model
  };
};

var setDirty = function setDirty(model) {
  return {
    type: _actionTypes2.default.SET_DIRTY,
    model: model
  };
};

var setInitial = function setInitial(model) {
  return {
    type: _actionTypes2.default.SET_INITIAL,
    model: model
  };
};

var setPending = function setPending(model) {
  var pending = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_PENDING,
    model: model,
    pending: pending
  };
};

var setValidity = function setValidity(model, validity) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return _defineProperty({
    type: options.errors ? _actionTypes2.default.SET_ERRORS : _actionTypes2.default.SET_VALIDITY,
    model: model
  }, options.errors ? 'errors' : 'validity', validity);
};

var setFieldsValidity = function setFieldsValidity(model, fieldsValidity) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return {
    type: _actionTypes2.default.SET_FIELDS_VALIDITY,
    model: model,
    fieldsValidity: fieldsValidity,
    options: options
  };
};

var setErrors = function setErrors(model, errors) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return setValidity(model, errors, _extends({}, options, {
    errors: true
  }));
};

var setFieldsErrors = function setFieldsErrors(model, fieldsErrors, options) {
  return setFieldsValidity(model, fieldsErrors, _extends({}, options, {
    errors: true
  }));
};

var resetValidity = function resetValidity(model) {
  return {
    type: _actionTypes2.default.RESET_VALIDITY,
    model: model
  };
};

var resetErrors = resetValidity;

var setTouched = function setTouched(model) {
  return {
    type: _actionTypes2.default.SET_TOUCHED,
    model: model
  };
};

var setUntouched = function setUntouched(model) {
  return {
    type: _actionTypes2.default.SET_UNTOUCHED,
    model: model
  };
};

var asyncSetValidity = function asyncSetValidity(model, validator) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    dispatch(setPending(model, true));

    var done = function done(validity) {
      dispatch(_batchActions2.default.batch(model, [setValidity(model, validity), setPending(model, false)]));
    };

    var immediateResult = validator(value, done);

    if (typeof immediateResult !== 'undefined') {
      done(immediateResult);
    }
  };
};

var setSubmitted = function setSubmitted(model) {
  var submitted = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
  return {
    type: _actionTypes2.default.SET_SUBMITTED,
    model: model,
    submitted: submitted
  };
};

var setSubmitFailed = function setSubmitFailed(model) {
  return {
    type: _actionTypes2.default.SET_SUBMIT_FAILED,
    model: model
  };
};

var setViewValue = function setViewValue(model, value) {
  return {
    type: _actionTypes2.default.SET_VIEW_VALUE,
    model: model,
    value: value
  };
};

var submit = function submit(model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return function (dispatch) {
    dispatch(setPending(model, true));

    var errorsAction = options.fields ? setFieldsErrors : setErrors;

    promise.then(function (response) {
      dispatch(_batchActions2.default.batch(model, [setSubmitted(model, true), setValidity(model, response)]));
    }).catch(function (error) {
      dispatch(_batchActions2.default.batch(model, [setSubmitFailed(model), errorsAction(model, error)]));
    });

    return promise;
  };
};

var submitFields = function submitFields(model, promise) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return submit(model, promise, _extends({}, options, {
    fields: true
  }));
};

var validate = function validate(model, validators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var validity = (0, _utils.getValidity)(validators, value);

    dispatch(setValidity(model, validity));
  };
};

var validateErrors = function validateErrors(model, errorValidators) {
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);
    var errors = (0, _utils.getValidity)(errorValidators, value);

    dispatch(setValidity(model, errors, { errors: true }));
  };
};

var validateFields = function validateFields(model, fieldValidators) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return function (dispatch, getState) {
    var value = (0, _get3.default)(getState(), model);

    var fieldsValidity = (0, _mapValues2.default)(fieldValidators, function (validator, field) {
      var fieldValue = field ? (0, _get3.default)(value, field) : value;

      var fieldValidity = (0, _utils.getValidity)(validator, fieldValue);

      return fieldValidity;
    });

    var validCB = options.onValid;
    var invalidCB = options.onInvalid;

    if (validCB || invalidCB) {
      var form = (0, _utils.getForm)(getState(), model);
      var formValid = form && !fieldsValidity.hasOwnProperty('') ? form.valid : true;
      var fieldsValid = options.errors ? !(0, _utils.isInvalid)(fieldsValidity) : (0, _utils.isValid)(fieldsValidity);

      if (validCB && formValid && fieldsValid) {
        validCB();
      } else if (invalidCB) {
        invalidCB();
      }
    }

    var fieldsValiditySetter = options.errors ? setFieldsErrors : setFieldsValidity;

    dispatch(fieldsValiditySetter(model, fieldsValidity));
  };
};

var validateFieldsErrors = function validateFieldsErrors(model, fieldErrorsValidators) {
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  return validateFields(model, fieldErrorsValidators, _extends({}, options, {
    errors: true
  }));
};

exports.default = {
  asyncSetValidity: asyncSetValidity,
  blur: blur,
  focus: focus,
  submit: submit,
  submitFields: submitFields,
  setDirty: setDirty,
  setErrors: setErrors,
  setInitial: setInitial,
  setPending: setPending,
  setPristine: setPristine,
  setSubmitted: setSubmitted,
  setSubmitFailed: setSubmitFailed,
  setTouched: setTouched,
  setUntouched: setUntouched,
  setValidity: setValidity,
  setFieldsValidity: setFieldsValidity,
  setFieldsErrors: setFieldsErrors,
  resetValidity: resetValidity,
  resetErrors: resetErrors,
  setViewValue: setViewValue,
  validate: validate,
  validateErrors: validateErrors,
  validateFields: validateFields,
  validateFieldsErrors: validateFieldsErrors
};